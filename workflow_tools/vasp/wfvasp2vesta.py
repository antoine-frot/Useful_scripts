#!/$HOME/virtual_env_python/bin/python3
"""
poscar_to_maxvesta.py

Convert an orbital file generated by vaspkit into a VESTA file with chosen defaults.

--- Input file format (required) ---
The input must be an orbital file generated by vaspkit, which has a POSCAR-style at the beginning.

Minimal required input header items (order-sensitive):
  0: TITLE line (free text)
  1: scale factor (float)
  2-4: 3 lattice vectors (three floats each)
  5: atom species line (e.g. "Ti   S" or "Ti S")
  6: atom counts line (e.g. "1    2")
  7: optional "Selective dynamics" or directly the coordinate type line
  8: coordinate type line: either "Direct"/"DIRECT"/"Cartesian"/"CART"
  9..: atomic coordinates (one per atom_count sum). Coordinates can include
       optional labels at the end; only first three floats are read.

--- VESTA_template file format (optional) ---
The script will look for a file named "VESTA_template" in the current directory. 
If found, it will parse the following parameters from it, with defaults presented below:
    BOUND = -0.49, 1.49, -0.49, 1.49, -0.49, 1.49
    ISOVALUE = 7.09285e-06
    ISOCOLOR = 255, 255, 0
    ISOOPACITY = 127, 255
    BG = 255, 255, 255

--- Usage ---
  python poscar_to_maxvesta.py <input.vasp>

--- Notes & caveats ---
* The script assumes coordinates are fractional (DIRECT). If coordinates are
  Cartesian you will need to re-run providing the "--cart" flag so
  the script will convert them into fractional coordinates using the provided
  lattice vectors.
* The script does NOT inspect or validate the volumetric grid; it simply
  references the original input file in the IMPORT_DENSITY line. Keep the
  grid data in the same directory as the generated .vesta file when opening
  with VESTA.

--- Author ---
Antoine Frot 31/10/2025
"""

import sys
import os
import argparse
from math import acos, degrees
import numpy as np

# ---------------------- User-tweakable template values ---------------------
# These values below are taken from the maximal .vesta template you pasted.
TEMPLATE_BOUND = (-0.49, 1.49, -0.49, 1.49, -0.49, 1.49)
TEMPLATE_ISOVALUE = 7.09285e-06
TEMPLATE_ISOCOLOR = (255, 255, 0)
TEMPLATE_ISOOPACITY = (127, 255)
TEMPLATE_BG = (255, 255, 255)
# End of user-tweakable block


def parse_template_file(template_path="VESTA_template"):
    """Parse template file and return dict with template values.
    
    Expected format in template file:
    BOUND = -0.49, 1.49, -0.49, 1.49, -0.49, 1.49
    ISOVALUE = 7.09285e-06
    ISOCOLOR = 255, 255, 0
    ISOOPACITY = 127, 255
    BG = 255, 255, 255
    
    Returns dict with parsed values, using script defaults for missing values.
    Write a default template file if none exists.
    """
    template_values = {
        'BOUND': TEMPLATE_BOUND,
        'ISOVALUE': TEMPLATE_ISOVALUE,
        'ISOCOLOR': TEMPLATE_ISOCOLOR,
        'ISOOPACITY': TEMPLATE_ISOOPACITY,
        'BG': TEMPLATE_BG
    }
    
    if not os.path.exists(template_path):
        with open(template_path, 'w') as f:
            f.write("BOUND = " + ", ".join(f"{x:g}" for x in TEMPLATE_BOUND) + "\n")
            f.write(f"ISOVALUE = {TEMPLATE_ISOVALUE}\n")
            f.write("ISOCOLOR = " + ", ".join(str(int(x)) for x in TEMPLATE_ISOCOLOR) + "\n")
            f.write("ISOOPACITY = " + ", ".join(str(int(x)) for x in TEMPLATE_ISOOPACITY) + "\n")
            f.write("BG = " + ", ".join(str(int(x)) for x in TEMPLATE_BG) + "\n")
        return template_values
    
    try:
        with open(template_path, 'r') as f:
            for line in f:
                line = line.strip()
                if '=' in line and not line.startswith('#'):
                    key, value = line.split('=', 1)
                    key = key.strip()
                    value = value.strip()
                    
                    if key == 'BOUND':
                        template_values['BOUND'] = tuple(map(float, value.split(',')))
                    elif key == 'ISOVALUE':
                        template_values['ISOVALUE'] = float(value)
                    elif key == 'ISOCOLOR':
                        template_values['ISOCOLOR'] = tuple(map(int, value.split(',')))
                    elif key == 'ISOOPACITY':
                        template_values['ISOOPACITY'] = tuple(map(int, value.split(',')))
                    elif key == 'BG':
                        template_values['BG'] = tuple(map(int, value.split(',')))
    except (ValueError, IOError) as e:
        print(f"Warning: Error reading template file {template_path}: {e}")
        print("Using script defaults")
    
    return template_values


def parse_poscar_header(lines):
    """Parse POSCAR-like header from lines (list of stripped lines).

    Returns: dict with keys: title, scale, a,b,c (vectors), species (list),
    counts (list), coords (list of [x,y,z]), coord_type ("Direct"/"Cartesian").

    Raises ValueError on malformed input.
    """
    if len(lines) < 9:
        raise ValueError("Input too short to be a POSCAR-like file")

    title = lines[0]
    scale = float(lines[1])
    a = np.array(list(map(float, lines[2].split())))
    b = np.array(list(map(float, lines[3].split())))
    c = np.array(list(map(float, lines[4].split())))

    species = lines[5].split()
    counts = list(map(int, lines[6].split()))
    total_atoms = sum(counts)

    # Read next lines until we encounter "Direct"/"DIRECT"/"Cartesian"/"CART"
    # Sometimes the coordinate type is on line 7, sometimes 8; we'll search.
    idx = 7
    coord_type = None
    # If lines[7] is 'DIRECT' or 'Cartesian' then coordinates start at 8.
    if lines[7].upper().startswith('D'):
        coord_type = 'Direct'
        coords_start = 8
    elif lines[7].upper().startswith('C'):
        coord_type = 'Cartesian'
        coords_start = 8
    else:
        if lines[8].upper().startswith('D'):
            coord_type = 'Direct'
            coords_start = 9
        elif lines[8].upper().startswith('C'):
            coord_type = 'Cartesian'
            coords_start = 9
        else:
            # fallback: assume DIRECT and start at line 8
            coord_type = 'Direct'
            coords_start = 8

    coords = []
    for i in range(coords_start, coords_start + total_atoms):
        parts = lines[i].split()
        if len(parts) < 3:
            raise ValueError(f"Not enough coordinate entries on line: {lines[i]}")
        coords.append([float(parts[0]), float(parts[1]), float(parts[2])])

    return {
        'title': title,
        'scale': scale,
        'a': a * scale,
        'b': b * scale,
        'c': c * scale,
        'species': species,
        'counts': counts,
        'coords': coords,
        'coord_type': coord_type,
    }


def lattice_lengths_angles(a, b, c):
    """Return [|a|, |b|, |c|, alpha(deg), beta(deg), gamma(deg)]
    where alpha = angle between b and c, beta between a and c, gamma between a and b.
    """
    def angle(u, v):
        cosv = np.dot(u, v) / (np.linalg.norm(u) * np.linalg.norm(v))
        cosv = max(-1.0, min(1.0, cosv))
        return degrees(acos(cosv))

    la = np.linalg.norm(a)
    lb = np.linalg.norm(b)
    lc = np.linalg.norm(c)
    alpha = angle(b, c)
    beta = angle(a, c)
    gamma = angle(a, b)
    return [la, lb, lc, alpha, beta, gamma]


def cartesian_to_fractional(coords_cart, a, b, c):
    """Convert Nx3 cartesian coords to fractional using matrix [a b c].
    returns list of [x_frac, y_frac, z_frac]
    """
    M = np.vstack([a, b, c]).T  # 3x3
    Minv = np.linalg.inv(M)
    fracs = [Minv.dot(np.array(pt)) for pt in coords_cart]
    return [[float(x) for x in pt] for pt in fracs]


def generate_vesta_content(parsed, inp_basename, template_values):
    """Generate the .vesta content string using the template blocks.
    The template mirrors the maximal VESTA file you provided with substitutions.
    """
    title = parsed['title']
    a, b, c = parsed['a'], parsed['b'], parsed['c']
    cell = lattice_lengths_angles(a, b, c)

    # Flatten species and per-atom entries to a list of atom labels
    species = parsed['species']
    counts = parsed['counts']
    labels = []
    for s, n in zip(species, counts):
        for i in range(n):
            labels.append(s)

    coords = parsed['coords']

    # craft STRUC block lines
    struc_lines = []
    for idx, (lab, coord) in enumerate(zip(labels, coords), start=1):
        x, y, z = coord
        # Use 6-decimal fractional formatting
        struc_lines.append( f"  {idx:2d} {lab:<4} {lab}{idx} 1.0000 {x:10.6f} {y:10.6f} {z:10.6f}    1a       1" )
        struc_lines.append("                            0.000000   0.000000   0.000000  0.00")

    lines = []
    lines.append("#VESTA_FORMAT_VERSION 3.5.4\n")
    lines.append("CRYSTAL\n\n")
    lines.append("TITLE\n")
    lines.append(title + "\n\n")
    lines.append("IMPORT_DENSITY 1\n")
    lines.append(f"+1.000000 {inp_basename}\n\n")

    # Minimal GROUP / SYMOP / TRAN blocks (copied from your template)
    lines.append("GROUP\n1 1 P 1\nSYMOP\n 0.000000  0.000000  0.000000  1  0  0   0  1  0   0  0  1   1\n -1.0 -1.0 -1.0  0 0 0  0 0 0  0 0 0\nTRANM 0\n 0.000000  0.000000  0.000000  1  0  0   0  1  0   0  0  1\n")
    lines.append("LTRANSL\n -1\n 0.000000  0.000000  0.000000  0.000000  0.000000  0.000000\n")
    lines.append("LORIENT\n -1   0   0   0   0\n 1.000000  0.000000  0.000000  1.000000  0.000000  0.000000\n 0.000000  0.000000  1.000000  0.000000  0.000000  1.000000\n")
    lines.append("LMATRIX\n 1.000000  0.000000  0.000000  0.000000\n 0.000000  1.000000  0.000000  0.000000\n 0.000000  0.000000  1.000000  0.000000\n 0.000000  0.000000  0.000000  1.000000\n 0.000000  0.000000  0.000000\n")

    # CELLP block using computed cell parameters
    lines.append("CELLP\n")
    lines.append(f"  {cell[0]:8.6f}   {cell[1]:8.6f}   {cell[2]:8.6f}  {cell[3]:8.6f}  {cell[4]:8.6f} {cell[5]:8.6f}\n")
    lines.append("  0.000000   0.000000   0.000000   0.000000   0.000000   0.000000\n")

    # STRUC block
    lines.append("STRUC\n")
    lines.extend([ln + "\n" for ln in struc_lines])
    lines.append("  0 0 0 0 0 0 0\n")

    # THERI block (thermal factors) default zero for each atom
    lines.append("THERI 1\n")
    for i in range(1, len(labels)+1):
        lines.append(f"  {i:2d}        {labels[i-1]}{i}  0.000000\n")
    lines.append("  0 0 0\n")

    # SHAPE, BOUND (substitute your boundary)
    lines.append("SHAPE\n  0       0       0       0   0.000000  0   192   192   192   192\n")
    b = template_values['BOUND']
    lines.append("BOUND\n")
    lines.append(f"   {b[0]:8.6f}      {b[1]:8.6f}      {b[2]:8.6f}      {b[3]:8.6f}      {b[4]:8.6f}      {b[5]:8.6f}\n")
    lines.append("  0   0   0   0  0\n")

    # SBOND, SITET, VECTR, VECTT, SPLAN blocks (copied)
    lines.append("SBOND\n  1    Ti     S    0.00000    2.74646  0  1  1  0  1  0.250  2.000 127 127 127\n  0 0 0 0\n")
    lines.append("SITET\n")
    for i in range(1, len(labels)+1):
        # use per-type coloring approximations from template
        if labels[i-1].upper().startswith('TI'):
            lines.append(f"  {i:2d}        {labels[i-1]}{i}  1.4700 120 202 255 120 202 255 204  0\n")
        else:
            lines.append(f"  {i:2d}        {labels[i-1]}{i}  1.0400 255 250   0 255 250   0 204  0\n")
    lines.append("  0 0 0 0 0 0\n")
    lines.append("VECTR\n 0 0 0 0 0\nVECTT\n 0 0 0 0 0\nSPLAN\n  0   0   0   0\n")

    # Many visual style blocks directly copied (LIGHTS, STYLE, ISURF, etc.)
    lines.append("LBLAT\n -1\nLBLSP\n -1\nDLATM\n -1\nDLBND\n -1\nDLPLY\n -1\nPLN2D\n  0   0   0   0\n")
    lines.append("ATOMT\n")
    lines.append("  1         Ti  1.4700 120 202 255 120 202 255 204\n  2          S  1.0400 255 250   0 255 250   0 204\n  0 0 0 0 0 0\n")

    lines.append("SCENE\n-0.044781  0.998904  0.013619  0.000000\n 0.395203  0.030234 -0.918096  0.000000\n-0.917502 -0.035730 -0.396123  0.000000\n 0.000000  0.000000  0.000000  1.000000\n  0.000   0.000\n  0.000\n  1.000\nHBOND 0 2\n\n")

    lines.append("STYLE\nDISPF 37753794\nMODEL   0  1  0\nSURFS   0  1  1\nSECTS  32  1\nFORMS   0  1\nATOMS   0  0  1\nBONDS   1\nPOLYS   1\nVECTS 1.000000\n")
    lines.append("FORMP\n  1  1.0   0   0   0\nATOMP\n 24  24   0  50  2.0   0\nBONDP\n  1  16  0.250  2.000 127 127 127\nPOLYP\n 204 1  1.000 180 180 180\n")

    lines.append("ISURF\n")
    isovalue = template_values['ISOVALUE']
    isocolor = template_values['ISOCOLOR']
    isoopacity = template_values['ISOOPACITY']
    lines.append(f"  1   0 {isovalue:.8e} {isocolor[0]} {isocolor[1]}   {isocolor[2]} {isoopacity[0]} {isoopacity[1]}\n  0   0   0   0\n")
    lines.append("TEX3P\n  1  0.00000E+00  1.00000E+00\n")
    lines.append("SECTP\n  1 -9.12572E-06  1.68851E-05  0.00000E+00  0.00000E+00  0.00000E+00  0.00000E+00\n")
    lines.append("CONTR\n 0.1 -1 1 1 10 -1 2 5\n 2 1 2 1\n   0   0   0\n   0   0   0\n   0   0   0\n   0   0   0\n")
    lines.append("HKLPP\n 192 1  1.000 255   0 255\nUCOLP\n   0   1  1.000   0   0   0\nCOMPS 1\nLABEL 1    12  1.000 0\nPROJT 0  0.962\n")
    
    bg = template_values['BG']
    lines.append(f"BKGRC\n {bg[0]} {bg[1]} {bg[2]}\nDPTHQ 1 -0.5000  3.5000\n")

    # LIGHT blocks copied
    for lid in range(4):
        lines.append(f"LIGHT{lid}\n 1.000000  0.000000  0.000000  0.000000\n 0.000000  1.000000  0.000000  0.000000\n 0.000000  0.000000  1.000000  0.000000\n 0.000000  0.000000  0.000000  1.000000\n 0.000000  0.000000 20.000000  0.000000\n 0.000000  0.000000 -1.000000\n")
        if lid == 0:
            lines.append("  26  26  26 255\n 179 179 179 255\n 255 255 255 255\n")
        else:
            lines.append("   0   0   0   0\n   0   0   0   0\n   0   0   0   0\n")

    lines.append("SECCL 0\n\nTEXCL 0\n\nATOMM\n 204 204 204 255\n  25.600\n")
    lines.append("BONDM\n 255 255 255 255\n 128.000\nPOLYM\n 255 255 255 255\n 128.000\nSURFM\n   0   0   0 255\n 128.000\nFORMM\n 255 255 255 255\n 128.000\nHKLPM\n 255 255 255 255\n 128.000\n")

    return ''.join(lines)


def convert_file(inp_path, out_path=None, coords_cartesian=False):
    """Convert a single file and write the .vesta file.

    coords_cartesian: if True, treat input coords as Cartesian and convert to
    fractional using lattice vectors.
    """
    with open(inp_path, 'r') as f:
        raw_lines = [ln.rstrip('\n') for ln in f]

    # Strip trailing empty lines and keep useful lines for header parsing
    stripped = [ln.strip() for ln in raw_lines if ln.strip() != '']

    parsed = parse_poscar_header(stripped)

    if coords_cartesian or parsed['coord_type'] == 'Cartesian':
        parsed['coords'] = cartesian_to_fractional(parsed['coords'], parsed['a'], parsed['b'], parsed['c'])

    inp_basename = os.path.basename(inp_path)
    if not out_path:
        out_path = os.path.splitext(inp_path)[0] + '.vesta'

    template_values = parse_template_file()
    content = generate_vesta_content(parsed, inp_basename, template_values)
    with open(out_path, 'w') as f:
        f.write(content)

    return out_path


def main():
    p = argparse.ArgumentParser(description='Convert orbitals generated by vaspkit to a VESTA file with chosen default (boundaries, ect.).')
    p.add_argument('input', nargs='?', help='Orbital file generated by vaspkit (51 menu).')
    p.add_argument('-o', '--output', help='Output .vesta file (default: input file with .vesta extension)')
    p.add_argument('--cart', action='store_true', help='Treat input coordinates as CARTESIAN and convert to fractional')
    args = p.parse_args()

    if not args.input:
        p.print_help()
        sys.exit(1)
    if not os.path.exists(args.input):
        print(f'File not found: {args.input}')
        sys.exit(1)
    out = convert_file(args.input, out_path=args.output, coords_cartesian=args.cart)


if __name__ == '__main__':
    main()
